1. Find the Duplicate Number: Given an array containing n+1 integers where each integer is between 1 and n (inclusive), 
prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

func findDuplicate(nums []int) int {
    // Initialize both pointers to first element
    slow := nums[0]
    fast := nums[0]
    
    // Phase 1: Find intersection point of slow and fast pointers
    for {
        slow = nums[slow]           // Move one step
        fast = nums[nums[fast]]     // Move two steps
        if slow == fast {
            break
        }
    }
    
    // Phase 2: Find entrance to the cycle
    fast = nums[0]
    for slow != fast {
        slow = nums[slow]
        fast = nums[fast]
    }
    
    return slow
}


2. Merge Intervals: Given a collection of intervals, merge all overlapping intervals.

func merge(intervals [][]int) [][]int {
    // Handle empty input
    if len(intervals) == 0 {
        return [][]int{}
    }
    
    // Sort intervals based on start time
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    
    // Initialize merged slice with first interval
    merged := make([][]int, 0)
    merged = append(merged, intervals[0])
    
    // Iterate through remaining intervals
    for i := 1; i < len(intervals); i++ {
        current := intervals[i]
        lastMerged := merged[len(merged)-1]
        
        // If current interval overlaps with last merged interval
        if current[0] <= lastMerged[1] {
            // Update end time of last merged interval
            lastMerged[1] = max(lastMerged[1], current[1])
        } else {
            // Add new interval to merged slice
            merged = append(merged, current)
        }
    }
    
    return merged
}

// Helper function to find maximum of two integers
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    // Test cases
    intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}
    fmt.Println("Original intervals:", intervals)
    fmt.Println("Merged intervals:", merge(intervals))
    
    intervals2 := [][]int{{1, 4}, {4, 5}}
    fmt.Println("\nOriginal intervals:", intervals2)
    fmt.Println("Merged intervals:", merge(intervals2))
}


3. Maximum Subarray: Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

func maxSubArray(nums []int) int {
    // Handle empty array case
    if len(nums) == 0 {
        return 0
    }
    
    maxSum := nums[0]
    currentSum := nums[0]
    
    // Iterate through array starting from second element
    for i := 1; i < len(nums); i++ {
        // Either start new subarray or extend existing one
        currentSum = max(nums[i], currentSum + nums[i])
        // Update maximum sum if current sum is larger
        maxSum = max(maxSum, currentSum)
    }
    
    return maxSum
}

// Helper function to find maximum of two integers
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    // Test cases
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    
    fmt.Printf("Input array: %v\n", nums)
    fmt.Printf("Maximum subarray sum: %d\n", result)
    
    // Additional test case
    nums2 := []int{5, 4, -1, 7, 8}
    result2 := maxSubArray(nums2)
    fmt.Printf("\nInput array: %v\n", nums2)
    fmt.Printf("Maximum subarray sum: %d\n", result2)
}


4. Two Sum: Given an array of integers, return indices of the two numbers such that they add up to a specific target.

func twoSum(nums []int, target int) []int {
        m := make(map[int]int)

        for i, num := range nums {
                complement := target - num

                if j, ok := m[complement]; ok {
                        return []int{j, i}
                }
                m[num] = i
        }
        return []int{}
}


5. Rotate Array: Rotate an array to the right by k steps, where k is non-negative.

func rotate(nums []int, k int) {
    k = k % len(nums)
    reverse(nums, 0, len(nums)-1)
    reverse(nums, 0, k-1)
    reverse(nums, k, len(nums)-1)
}

func reverse(nums []int, start, end int) {
    for start < end {
        nums[start], nums[end] = nums[end], nums[start]
        start++
        end--
    }
}
6. Spiral Matrix: Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

func spiralOrder(matrix [][]int) []int {
    // Handle empty matrix
    if len(matrix) == 0 {
        return []int{}
    }
    
    // Initialize result slice and boundaries
    result := make([]int, 0)
    rowBegin := 0
    rowEnd := len(matrix) - 1
    colBegin := 0
    colEnd := len(matrix[0]) - 1
    
    // Traverse in spiral order
    for rowBegin <= rowEnd && colBegin <= colEnd {
        // Traverse right
        for j := colBegin; j <= colEnd; j++ {
            result = append(result, matrix[rowBegin][j])
        }
        rowBegin++
        
        // Traverse down
        for i := rowBegin; i <= rowEnd; i++ {
            result = append(result, matrix[i][colEnd])
        }
        colEnd--
        
        // Traverse left
        if rowBegin <= rowEnd {
            for j := colEnd; j >= colBegin; j-- {
                result = append(result, matrix[rowEnd][j])
            }
            rowEnd--
        }
        
        // Traverse up
        if colBegin <= colEnd {
            for i := rowEnd; i >= rowBegin; i-- {
                result = append(result, matrix[i][colBegin])
            }
            colBegin++
        }
    }
    
    return result
}

func main() {
    // Test cases
    matrix1 := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    
    matrix2 := [][]int{
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
    }
    
    fmt.Printf("Matrix 1:\n")
    printMatrix(matrix1)
    fmt.Printf("Spiral order: %v\n\n", spiralOrder(matrix1))
    
    fmt.Printf("Matrix 2:\n")
    printMatrix(matrix2)
    fmt.Printf("Spiral order: %v\n", spiralOrder(matrix2))
}

// Helper function to print matrix
func printMatrix(matrix [][]int) {
    for _, row := range matrix {
        fmt.Println(row)
    }
}


7. First Missing Positive: Given an unsorted integer array, find the smallest missing positive integer.

int firstMissingPositive(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
            swap(nums[i], nums[nums[i] - 1]);
        }
    }
    for (int i = 0; i < n; i++) {
        if (nums[i] != i + 1) return i + 1;
    }
    return n + 1;
}

alternative
-----------

int firstMissingPositive(int nums[], int n) {
    qsort(nums, n, sizeof(int), 
          (int (*)(const void *, const void *)) &strcmp); // Sort the array (assumes strcmp works for comparing integers)

    int missing = 1;
    for (int i = 0; i < n; i++) {
        if (nums[i] == missing) { // Found the next expected positive
            missing++;
        } else if (nums[i] > missing) { // Reached a number greater than expected
            return missing;
        }
    }
    return missing; // If all positive numbers from 1 to n are present
}

8. Product of Array Except Self: Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> output(n, 1);

    // Calculate prefix products
    int prefix = 1;
    for (int i = 0; i < n; i++) {
        output[i] = prefix;
        prefix *= nums[i];
    }

    // Calculate suffix products (from the right)
    int suffix = 1;
    for (int i = n - 1; i >= 0; i--) {
        output[i] *= suffix;
        suffix *= nums[i];
    }

    return output;
}

9. Longest Consecutive Sequence: Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

int arr[] = {100, 4, 200, 1, 3, 2};
int n = 6;

output : 4 ([1, 2, 3, 4])

int longestConsecutive(int arr[], int n) {
    int longest = 0; 

    for (int i = 0; i < n; i++) {
        int currentNum = arr[i];
        int currentStreak = 1;

        // Keep checking for consecutive numbers
        while (currentNum + 1 == arr[i + currentStreak]) { 
            currentStreak++;
        }

        // Update longest streak if needed
        if (currentStreak > longest) {
            longest = currentStreak;
        }
    }
    return longest;
}

10. Jump Game: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. 
Determine if you are able to reach the last index.

bool canJump(vector<int>& nums) {
    int lastPos = nums.size() - 1;
    for (int i = nums.size() - 1; i >= 0; i--) {
        if (i + nums[i] >= lastPos) {
            lastPos = i;
        }
    }
    return lastPos == 0;
}

11. remove duplicates in sorted array

int removeDuplicates(int arr[], int n) {
    if (n==0 || n==1) {
        return n;
    }

    // `i` is the slow-runner, `j` is the fast-runner
    int i = 0;
    for (int j = 1; j < n; j++) {
        // If the current element is not equal to the next element, move `i` forward
        // and replace the element at `i` with the current element
        if (arr[j] != arr[i]) {
            i++;
            arr[i] = arr[j];
        }
    }

    // The new length is `i + 1` because `i` is zero-based
    return i + 1;
}

12. Contains Duplicate - Check if array has duplicate elements

func containsDuplicate(nums []int) bool {
    seen := make(map[int]bool)
    for _, num := range nums {
        if seen[num] {
            return true
        }
        seen[num] = true
    }
    return false
}


13. Find Missing Number - Find missing number in range [0,n]

func missingNumber(nums []int) int {
    n := len(nums)
    expected := n * (n + 1) / 2
    actual := 0
    for _, num := range nums {
        actual += num
    }
    return expected - actual
}

14. Merge Sorted Arrays: Merges from end to avoid overwriting. Time O(m+n), Space O(1)

func merge(nums1 []int, m int, nums2 []int, n int) {
    p1 := m - 1
    p2 := n - 1
    p := m + n - 1
    
    for p2 >= 0 {
        if p1 >= 0 && nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
}

15. Move Zeroes - Move all zeroes to end maintaining order
func moveZeroes(nums []int) {
    nonZero := 0
    for i := 0; i < len(nums); i++ {
        if nums[i] != 0 {
            nums[nonZero], nums[i] = nums[i], nums[nonZero]
            nonZero++
        }
    }
}

16. Intersection of Two Arrays - Find common elements

func intersection(nums1 []int, nums2 []int) []int {
    set1 := make(map[int]bool)
    for _, num := range nums1 {
        set1[num] = true
    }
    
    result := make([]int, 0)
    seen := make(map[int]bool)
    for _, num := range nums2 {
        if set1[num] && !seen[num] {
            result = append(result, num)
            seen[num] = true
        }
    }
    return result
}


17. Given a large integer represented as an array of digits, the task is to add 1 to the number and return the resulting array. 
Each element in the array represents a single digit, and the digits are arranged from most significant to least significant.

func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    k := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[i-1] {
            nums[k] = nums[i]
            k++
        }
    }
    return k
}


18. Problem: Given an array with only 0s, 1s, and 2s in any order, sort them in-place. Think of these as three colors (red, white, blue) 
that need to be arranged in the correct order.

func sortColors(nums []int) {
    low, mid, high := 0, 0, len(nums)-1
    
    for mid <= high {
        switch nums[mid] {
        case 0:
            nums[low], nums[mid] = nums[mid], nums[low]
            low++
            mid++
        case 1:
            mid++
        case 2:
            nums[mid], nums[high] = nums[high], nums[mid]
            high--
        }
    }
}

19. Intersection: Uses hashmap to track common elements. Time O(n+m), Space O(n)

func intersection(nums1 []int, nums2 []int) []int {
    set1 := make(map[int]bool)
    for _, num := range nums1 {
        set1[num] = true
    }
    
    result := make([]int, 0)
    seen := make(map[int]bool)
    for _, num := range nums2 {
        if set1[num] && !seen[num] {
            result = append(result, num)
            seen[num] = true
        }
    }
    return result
}

20. Find element that appears once while others appear twice.

func singleNumber(nums []int) int {
    result := 0
    for _, num := range nums {
        result ^= num
    }
    return result
}




